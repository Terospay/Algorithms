#include <iostream>
#include <vector>
#include <set>

using namespace std;

int n, k;                             //n — число вершин в первой доле,
                                      // k — во второй доле,
                                      // g[v] — список рёбер из вершины v первой доли
                                      // (т.е. список номеров вершин, в которые ведут эти рёбра из v).
                                      // Вершины в обеих долях занумерованы независимо,
                                      // т.е. первая доля — с номерами 1 ... n, вторая — с номерами 1 ... k.

vector < vector<int> > g;
vector<int> mt;
vector<char> used;
                                      //Дальше идут два вспомогательных массива: mt[] и used[].
                                      // mt[] — содержит в себе информацию о текущем паросочетании.
                                      // Для удобства программирования, информация эта содержится только для вершин второй доли:
                                      // mt[i] — это номер вершины первой доли, связанной ребром с вершиной i второй доли
                                      // (или -1, если никакого ребра паросочетания из i не выходит).
                                      // Второй массив — used[] — обычный массив "посещённостей" вершин в обходе в глубину
                                      // (он нужен, просто чтобы обход в глубину не заходил в одну вершину дважды).
                                      //функция try_kuhn — и есть обход в глубину.
                                      // Она возвращает true, если ей удалось найти увеличивающую цепь из вершины v,
                                      // при этом считается, что эта функция уже произвела чередование паросочетания вдоль найденной цепи.
                                      //Внутри функции просматриваются все рёбра, исходящие из вершины v первой доли,
                                      // и затем проверяется: если это ребро ведёт в ненасыщенную вершину to,
                                      // либо если эта вершина to насыщена, но удаётся найти увеличивающую цепь рекурсивным запуском из mt[to],
                                      // то мы говорим, что мы нашли увеличивающую цепь,
                                      // и перед возвратом из функции с результатом true производим чередование в текущем ребре:
                                      // перенаправляем ребро, смежное с to, в вершину v.
                                      //В основной программе сначала указывается,
                                      // что текущее паросочетание — пустое (список mt[] заполняется числами -1).
                                      // Затем перебирается вершина v первой доли, и из неё запускается обход в глубину try_kuhn,
                                      // предварительно обнулив массив used.
bool try_kuhn (int v) {
  if (used[v])  return false;
  used[v] = true;
  for (size_t i=0; i<g[v].size(); ++i) {
    int to = g[v][i];
    if (mt[to] == -1 || try_kuhn (mt[to])) {
      mt[to] = v;
      return true;
    }
  }
  return false;
}

int main() {

  //ввод значений n, k и g

  mt.assign (k, -1);
  int MCBM_size = 0;
  for (int v=0; v<n; ++v) {
    used.assign (n, false);
    bool flag = try_kuhn (v);
    if (flag){
      ++MCBM_size;
    }
  }


  for (int i=0; i<k; ++i)              //вывод паросочетания
    if (mt[i] != -1)
      printf ("%d %d\n", mt[i]+1, i+1);





  return 0;
}